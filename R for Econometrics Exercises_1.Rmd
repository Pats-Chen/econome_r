---
title: "沐刃经济塾：R语言教程第一课"
author:
  - Jiazhe Chen
  - Shi Liang
date: "December 13, 2018"
documentclass: ctexart
output:
  rticles::ctex:
    fig_caption: yes
    number_sections: yes
    toc: yes
classoption: "hyperref,"
---

\newpage

# 课前练习

```{r eval=FALSE}
5
#input values

1+1
#try add function

5-4

3*5

7/3
#divide function

(1+1)*2
#parentheses

3^2

3**2
#power

10%%3
#modulo

#sharp mark is comment

v<-5
#assign variables

w=5
#another way to assign variables

v
#print variables

w <- 6
w
#space doesnt matter

W
#R is cap sensitive

bad name <- 10
#don't name a variable using space

bad_name <- 10
#use _ instead

bad_order
bad_order<-12
#order of the command matters

budget<-20
consumption<-10
saving<-budget-consumption
saving
#use variables to calculate

"bear"
'911'
#different data types: strings/character

class("bear")
#check data type

v<-5
class(v)
#integer and decimal numbers are numeric

3<5
#different data types: Boolean/logical

FALSE
#Boolean values, or logical values

class(3<5)
'Pats'=="Pats"

class(True)
class('True')
#tricky part! what is True written here?

5+'5'
#operator such as + need 2 certain input to calculate

class(5)
#functions: class is a function

5+5
#+ is also a function

class(class(5))
#tricky part!

myfunction<-function(number1,number2){
        return(number1+number2)
        }
#build an + function!
myfunction(1,1)
#test my funcion!

c(1,2)
#use c function to create vectors

c(1 2)
1,2
#wrong vectors


c(1,2)+c(1,2)
c(1,2)*c(1,2)
c(1,2)/c(1,2)
c(1,2)^c(1,2)
#vector calculation

c(1,2)[2]
vector<-c(1,2)
vector[1]
#indexing in vector

c('a',"b")
c(TRUE, FALSE, 3<5)


c('a',3<5,5)
#tricky part! what type is "3<5"?

```

# 导论

计算机编程语言是用于编写指令，使得计算机可以按照我们的要求完成某些工作的语言。人类在说话的时候使用自己的语言，计算机也是如此。对于每一个计算元件来说，它只能够理解诸如0和1这样的内容，是因为计算元件读取信息是依靠电路开关的“开”和“关”来实现的。如果为了让计算机理解我们发出的指令需要我们自己编写一串由“0”和“1”构成的代码的话，编程将会非常低效而繁杂。

为了解决这个问题，计算机科学家们开发了计算机编程语言。现代的计算机编程语言通常指某些能够让一般人更加容易学习的，与人类使用的语言相似的代码模式，使得我们不必再学习如何编写“0”和“1”的指令让计算机能够运作。

不同的计算机编程语言使用不同形式的语法和机构，正如英语汉语与日语各自拥有不同的语法和结构一样。R语言是一种面向对象的，弱类型的语言。不同于有些同学曾经接触过的C/C++等强类型语言。其具体差异将在今后的课程中让大家感受到，目前不需要明白其中的区别。

不管是哪一种编程语言，都能够用于指示计算机完成它的基本功能，也就是计算。就像大家在课前练习中尝试的那样，我们可以使用R语言编写一些简单的数学运算指令，然后交给计算机计算相应的结果。如：```` 1538*45656 ````。

使用R语言，我们不仅可以进行常见的四则运算，还能够利用一些R语言自带的**函数**，来完成一些常用计算器上所没有的功能。如：```` abs(v) ````，```` sqrt(v) ````，```` exp(v) ````，```` log(v) ````，```` log(v,b) ````，```` round(v,s) ````，```` factorial(n) ````以及```` choose(n,k) ````，等等。

**函数**是我们在学习R语言时遇到的第一个重要概念。在很多意义上计算机编程语言中的函数概念与数学中的函数概念是一样的。把```` x ````输入```` y=f(x) ````中，我们就能够计算出```` y ````的值。正如我们刚才做的那样，如果我们想要知道四的平方根，只需要输入```` sqrt(4) ````，R Studio的Console就会为我们返回```` 2 ````这个数。与数学不同的是，编程语言中的函数涵盖了更为广泛的涵义。想象一个插着两个管道的黑箱子，我们不知道它里面有什么样的结构，但是只要知道它的接收管道和输出管道分别要求我们输入什么样的东西，输出什么样的东西，我们就可以使用它了。不管黑箱子要求我们输入的是一个数字，两个数字，一个向量，两个矩阵，还是以上这些东西的总和。只要我们满足了这一要求，黑箱子就会输出一些东西。而这些东西的输出方式当然是根据黑箱子内部的运算结构决定的。然而最好的地方就在于，即使我们不知道黑箱子内部的结构究竟是怎么样的，只要我们能够仔细地观察输入内容与输出内容之间的关系，我们就能够猜想，试错，从而理解黑箱子对于我们的作用。目前大家需要理解，所谓函数就是一种稍微复杂一些的运算工具，它在本质上跟我们使用的四则运算符号，也就是加减乘除没有什么区别。

在大致理解了函数的概念以后，我们就要问，是否每次使用函数的时候都必须把输入端的内容具体明示呢？换句话说，是否每次计算平方根的时候都必须告诉计算机要被开根的对象具体是多少呢？当然并非如此。编程语言中的函数同样能够发挥如同数学中的函数一样的概念。在使用某个函数时，我们并不总是在使用它某个特定的取值，而是在使用它作为运算的关系。还是用平方根来说明吧。当我们在说平方根的时候，我们并不要求它必须是四的平方根，而可以是任何数，具体来说是任何正数和零的平方根。抛开了具体的求值对象的运算使得我们能够接触到运算对象以外的部分，也就是函数作为运算关系的内涵。这一想法对于学习编程语言非常重要，大家将会在随后的练习中感受到。

既然函数可以不指定具体的运算对象，那么是否可以让计算机理解```` f() ````这样的表述呢？答案是不行。为了能够让计算机理解我们想要表达的“任何数的平方根”这一要求，我们需要**变量**这个概念。什么是变量？变量是一个可以储存东西的盒子，通常我们会给变量取一个名字，比如可以将我们想要计算平方根的对象命名为```` variable ````。这样，每当我们想要计算某个数的平方根时，只要将```` variable ````赋值，我们就可以计算```` sqrt(variable) ````了。可以看到，这一表达是不受到```` variable ````的具体取值的影响的。也就是说，它可以表示任何具体数字的平方根。在编程语言中，变量与在数学中最大的不同在于，在使用一个变量前，必须先对这个变量进行赋值。如```` variable<-4 ````，就是一个赋值语句。在赋值后，计算机会将内存中的某个地址存入四这个数字。随后每当我们调用```` variable ````时，计算机就会根据这个地址在内存中找到四，从而计算出它的平方根。当我们不再需要某个变量时，则可以使用```` rm(variable) ````，以便将内存中对应的地址与这个变量名的联系删除。

函数在编程语言中之所以重要，是因为通过调用函数，我们就能够简化复杂的程序设计。不管是怎么样复杂的程序结构，只要我们把它分解成一个个函数，并分别编写每一个函数的内容，最后把它组合起来，就能够相对轻松地完成。我们将在今后的课程中尝试进行略为复杂的程序设计。

到目前为止我们只使用了R语言作为计算器所能够发挥的功能。在下一章里，我们将要学习不同的数据类型与结构。

# 初识数据类型与结构

在上一章里，我们只使用过四这样的数字。实际上，R语言允许将很多种类的数据类型与结构存入变量中。比如：```` variable<-"apple" ````。形如```` "apple" ````这样的数据被称为字符串，或称字母。显然，字符串与数字不同，它不能进行数学运算。由于在上一章我们已经理解，R语言并不只能进行数学运算，因此随后我们将会看到字符串将能够怎样用于我们自己编写的程序中。值得注意的是，形如```` "4" ````这样的数据也并不是数字，而是一种字符串。这是因为只要被一对单引号或双引号包含的字符，都会被计算机以字符串的形式储存。请大家要注意区分。

除了字符串以外，R语言还能够理解逻辑值，或称布尔值。常见的布尔值有两种取值，分别是```` TRUE ````和```` FALSE ````。首先需要注意的是，布尔值必须全部都是大写的。由于R语言对大小写敏感，因此首字母大写，或是小写的单词将不会被计算机正确理解。

为什么需要布尔值？因为很多时候，我们需要判断一个表达式的真假。如：```` x!=y ````，```` x ````是否不等于```` y ````？计算机会计算这一表达式的真假，然而返回给我们计算的结果。在这里，如果```` x<-1 ````，```` y<-2 ````，则表达式为假，返回值将为```` FALSE ````。类似地，我们还可以计算```` x==y ````，```` x<y ````，```` x<=y ````，```` x>=y ````，```` x>y ````，```` !y ````，```` x|y ````和```` x&y ````的返回值。灵活使用布尔值能够帮助我们解决数据处理时的很多问题。请大家思考一下，如何用R语言表达“年龄大于等于22岁，受教育程度为大学本科及以上的男性”这个筛选条件？

尝试以下命令，观察发生了什么：
```{r eval=FALSE}
TRUE==1
NA==TRUE
NA!=FALSE
NaN>TRUE
class(NA)
```

除了字符串与布尔值以外，R语言还能够理解成分值，或称```` factor ````。由于这一数据类型在计量经济学实践中并不常用，因此此处不具体展开。

随后大家将要接触到的是R语言中非常重要的**向量**。通常来说向量并不是一种基础数据类型，而是一种数据结构。但是此处大家并不需要对此作严格区分，可把它当做数据类型的一种来理解。今后我们还会接触到其他类似的，具有结构的数据类型，请大家与向量的概念进行联系理解。

在理解向量之前，首先需要知道如何构建一个向量。在R语言中，我们可以使用```` c() ````这一函数来构建一个向量。如：```` c(1,2,3) ````就构成了一个向量。在这里，```` c() ````是一个函数，它要求我们输入任意个元素，而将会返回给我们一个这些元素组成的向量。在构建了一个向量以后，我们就能够将它赋值给任意的变量，如：```` x<-c(1,2,3) ````。

尝试以下命令，观察发生了什么：

```{r eval=FALSE}
vector("character",length=5)
character(5)
numeric(5)
logical(5)
```

向量在数学上可以理解成一组数，在R语言中也可以这样理解。需要注意的是，向量里的元素是有序的。也就是说，```` c(1,2,3) ````中的第一个元素将会是```` 1 ````，而不会是```` 2 ````或者```` 3 ````。这是非常重要的，请大家记住这一点。不仅如此，向量中的元素还可以是字符串或者布尔值。但是，单个向量中的不同元素必须得是同一数据类型的。也就是说，如果一个向量中的第一个元素和第二个元素不是同一种数据类型的话，R语言将会自动把它进行转换，以满足这一要求。请大家自己尝试使用不同类型的数据组成一个向量，并观察发生了什么。

在某些情况下，我们并不想让R语言为我们自动转换数据类型，而希望按照自己的需要来转换数据类型。此时我们可以使用以下命令来帮助我们完成。

```{r eval=FALSE}
as.numeric('1')
as.character(1)
as.logical(1)
```

此外，对于其元素为数字的向量，数学上定义的向量运算的表达方式与R语言中的表达方式并不完全相同。请大家自己尝试使用上一章学习的常见数学运算符，观察它们作用在向量上时的表现。

除了数学运算以外，R语言还提供了一些适用于向量对象的函数。请大家自己尝试使用以下命令，并观察发生了什么。

```{r eval=FALSE}
length(x)
max(x)
min(x)
sort(x)
sum(x)
prod(x)
rep(5,6)
seq(5)
seq(5,10)
5:10
5:-2
seq(5,10,2)
```

由于向量由元素构成，因此当我们只需要使用某个向量中的子向量，或者是单个元素时，可以通过提取向量中的某个部分来获得想要的部分。需要提取向量时，不同于函数的输入符号，我们使用中括号来表示需要提取的元素位置。既然向量中的元素都是有序的，我们就可以通过序号来找到向量中的某些特定元素。更进一步地，如果我们为向量中的元素添加标记，则可以使用标记来获得我们想要的向量。

```{r eval=FALSE}
x<-seq(5,10)
x
x[1]
x[2:4]
x[x>6]
x[-1]
x<-c(x,11)
index<-c("first","second","third","fourth",
         "fifth","sixth","seventh")
names(x)<-index
x
x["first"]
```

在以上练习中，我们注意到，由于R语言会把单个对象当做是一维的向量来处理，因此当我们想要为一个向量添加元素，或是将两个向量合并时，只需要将两个对象都用于构建一个新的向量，并将新向量存储在原变量的地址中即可。

**矩阵**是R语言中非常强大的另一种数据结构之一。R语言中提供了丰富的矩阵数学计算函数，但是由于计量经济学应用中，我们通常并不大量使用矩阵的数学计算，因此我们将会主要学习如何构建矩阵，以及如何像操作向量一样操作矩阵。请大家自己尝试使用以下命令，观察矩阵的构建，提取与修改是如何实现的。

```{r eval=FALSE}
m<-matrix(c(1,2,3,4),nrow=2)
m<-matrix(c(1,2,3,4),nrow=2,byrow=TRUE)
row1<-c(1,2,3); row2<-c(4,5,6)
a<-rbind(row1,row2)
dim(a)
col1<-c(1,4)
col2<-c(2,5)
col3<-c(3,6)
b<-cbind(col1,col2,col3)
colnames(b)<-c('1','2','3')
rownames(b)<-c('1st','2nd')
b
c<-diag(c(1,2,3))
c
d<-diag(4)
d
diag(d)
b[2,2]
b[,3]
b[c(1,2),]
a+b
a*b
e<-t(b)
f<-a%*%e
solve(f)
```

在本章的最后，我们将要学习R语言中的**列表**结构。与向量不同，列表是各种对象的一个集合。在一个列表中可以存在不同的元素类型。同时，列表中的元素也可以被命名。当我们需要提取列表中的某些元素时，则需要使用美元符号提取。

```{r eval=FALSE}
superlist<-list(name1=1,name2=TRUE,name3="5")
nameoflist<-names(superlist)
nameoflist[1]
superlist$name1
superlist[[1]]
superlist[["name2"]]
ultimatelist<-append(superlist,FALSE,after=4)
ultimatelist
otherlist<-list(gender="male")
fulllist<-c(superlist,otherlist)
fulllist
```

除了以上介绍的数据类型与结构，R语言中还有其他的数据结构存在。此外，用户还可以通过自己定义数据结构的方式来满足自己的实际需求。我们将在随后的课程中进一步为大家讲解其他数据结构。

# 初识程序结构

在上一章中，我们主要学习了R语言中的各种数据类型与结构。在理解了数据以后，我们通常需要设计程序结构，使得它能够帮助我们完成计算，获得想要的结果。

第一种结构称为条件结构。当我们需要根据某些情况执行不同的操作时，我们需要使用条件结构语句来让计算机完成目标。以下命令是一些简单的条件结构示例。

```{r eval=FALSE}
if (p<=0.05) {
        decision<-'reject H0!'
} else {
        decision<-"don't reject H0!"
}
#example 1

if (p<=0.01) {
        significance<-"***"
} else if (p<=0.05) {
        significance<-"**"
} else if (p<=0.1) {
        significance<-"*"
} else {
        significance<-"_"
}
#example 2
```

第二种结构称为循环结构。当我们需要反复地根据某些条件执行同样的操作时，我们需要使用循环结构语句来让计算机完成目标。在很多情况下，循环结构由一个循环子控制。当循环子遍历某个给定的向量时，则要求计算机执行给定的同一操作，直到向量中的元素全部被遍历。以下命令是一些简单的循环结构示例。

```{r eval=FALSE}
sum<-0
for (i in 1:10) {
        sum<-sum+i
}
print(sum)
#example 1

sum<-0
for (i in 1:6) {
        if (i%%2==0) {
                sum<-sum+i^3
        } else {
                sum<-sum+i^2
        }
}
print(sum)
#example 2
```

与条件结构不同的是，R 语言中提供了很多不同的方式来帮助我们编写循环结构。在某些特定情况下，灵活使用不同的语句将会极大地简化代码结构与可读性，使得作业更为顺畅。以下命令是使用其他方式实现的循环结构示例。

```{r eval=FALSE}
i<-0
while (i<=6) {
        print(i)
        i<-i+1
}
#example 1
x<-1:5
sqrtx<-lapply(x,sqrt)
sqrtx
#example 2
```

在理解了简单的程序结构以后，我们可以利用R语言强大的自定义函数的功能，来编写满足特定需求的函数。正如我们在学习函数时所解释的那样，当我们使用函数时，我们主要关心它输入和输出的对象。而当我们需要自己编写一个函数时，除了输入和输出对象，我们还需要关心它的运算方法。一个好的函数应该至少满足以下几个要求：一，能够按照我们设想的方式计算输入对象的结果；二，当输入对象不符合要求，或是输出对象不符合要求时，应当能够报告错误；三，运算速度应当尽可能快；四，函数的代码应当尽可能容易被其他读者理解。以下命令是自定义一个简单的函数的示例。

```{r eval=FALSE}
mysqrt<-function(number) {
        if (number>=0) {
                return(sqrt(number))
        } else {
                return("Warning: number should be 
                       positive or 0")
        }
}
mysqrt(number=9)
mysqrt(-1)
```

本章中的学习内容与上一章不同的是，我们编写的代码形成了一些特定的结构。需要注意的是，在特定结构中赋值的变量将不能够在该结构外获取，我们称这样的变量为**局部变量**。在以下示例中，在```` mysum() ````函数中第一次被赋值的变量```` numbersum ````就是一个局部变量。此时```` numbersum ````只存在于```` mysum() ````函数内部，一旦```` mysum() ````函数调用结束，函数内部的变量就将不再存储于内存中，因而也无法在函数外部获取。

```{r eval=FALSE}
mysum<-function(number) {
        numbersum=0
        for (i in 1:number) {
                numbersum<-numbersum+i
        }
        return(numbersum)
}
mysum(5)
#call function mysum()
numbersum
#local variable not found
```

与局部变量相对应的概念是全局变量。实际上，除了特别说明的变量以外，目前为止我们使用的变量都是全局变量。全局变量的特点是，不管是在特定结构外部，还是在特定结构内部，我们都能够获取该变量。例如，我们在学习向量的时候赋值的向量```` x ````就可以在```` mysum() ````函数内部或外部获取，请大家自己尝试编写代码验证。

在理解了简单的函数结构以后，我们很快就可以通过把函数与条件，循环结构结合，构造出非常复杂的自定义函数了。然而在某些情况下，过于复杂或冗长的函数结构可能会损害代码的可读性。为了编写的代码能够被自己和他人顺利地维护，需要在编写函数时预先考虑到代码的长度与复杂程度，以便使自己和他人在阅读代码的时候能够理解其构造。与其他编程语言一样，R语言同样支持一些相对抽象的函数构造方法，从而简化代码形式，增加代码可读性，我们要学习的其中一种就是**递归方法**。

递归方法与通常的程序结构并不一样。通常的程序结构要求我们在调用函数，或是在获取变量取值之前，必须先定义该函数，或是赋值该变量，否则计算机就会报错。然而在递归方法中，我们将会发现，在某些特定的情况下，即使某函数还没有被定义，我们也可以调用它。以下命令是一个简单的递归函数的示例，请大家仔细观察发生了什么。

```{r eval=FALSE}
mysum2<-function(number) {
        numbersum=0
        if (number==1) {
                return(1)
        } else {
                numbersum<-mysum2(number-1)+number
                return(numbersum)
        }
}
mysum2(5)
```

# 课堂练习

1. 打印九九乘法表（提示：需要使用```` as.character() ````和```` paste(a,b) ````函数，请自行搜索它们的功能）；
2. 编写函数，使得用户输入85-100分时，返回“Excellent”，输入70-84分时，返回“Good”，输入60-69分时，返回“Not Bad”，输入0-59分时，返回“Remain to be Improved”，输入其他非整数类型数据时，返回“System Error: score can only be integer”；
3. 编写函数，使得用户输入自己与相亲对象的星座后能够返回缘分建议。星座间的缘分请大家在网上自行搜索获得；
4. 编写函数，使得用户输入1-100之间的任意2个整数后，返回它们的最大公约数；

# 课后练习

1. 计算斐波那契数列前30个数字之和；
2. 编写一个函数，使得它能够猜出由用户指定的，在1-100之间的某个数字，并使猜测的次数尽可能少（每次猜测后能够获知猜测数字相对目标数字的大小关系）；